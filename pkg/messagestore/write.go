package messagestore

import (
	"encoding/binary"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/asuffield/ouro-tools/pkg/messagestore/parse"
)

func (s *Store) Write(path string, template *Store) error {
	if template != nil {
		if template.readBinary {
			return s.WriteBin(path, template)
		} else {
			return s.WriteText(path, template)
		}
	}

	if strings.HasSuffix(path, ".bin") {
		return s.WriteBin(path, nil)
	} else {
		return s.WriteText(path, nil)
	}
}

func writeU32(w io.Writer, i int) error {
	u := uint32(i)
	return binary.Write(w, binary.LittleEndian, &u)
}

func (s *Store) WriteBin(path string, template *Store) error {
	f, err := os.Create(path)
	defer f.Close()
	if err != nil {
		return err
	}

	if err := writeU32(f, BinarySignature); err != nil {
		return fmt.Errorf("failed to write message count to %s: %s", path, err)
	}

	if err := s.messageTable.Write(f); err != nil {
		return fmt.Errorf("failed to write messages table to %s: %s", path, err)
	}

	if err := s.variableTable.Write(f); err != nil {
		return fmt.Errorf("failed to write variable table to %s: %s", path, err)
	}

	if err := writeU32(f, len(s.messages)); err != nil {
		return fmt.Errorf("failed to write message count to %s: %s", path, err)
	}

	for name, msg := range s.messages {
		if err := writeU32(f, len(msg.id)); err != nil {
			return fmt.Errorf("failed to write length of string %s to %s: %s", name, path, err)
		}
		if _, err := f.WriteString(msg.id); err != nil {
			return fmt.Errorf("failed to write string %s to %s: %s", name, path, err)
		}
		if err := writeU32(f, msg.index); err != nil {
			return fmt.Errorf("failed to index of %s to %s: %s", name, path, err)
		}
		if err := writeU32(f, msg.helpIndex); err != nil {
			return fmt.Errorf("failed to help index of %s to %s: %s", name, path, err)
		}
		if err := writeU32(f, len(msg.varIndices)); err != nil {
			return fmt.Errorf("failed to variable count of %s to %s: %s", name, path, err)
		}
		for i, index := range msg.varIndices {
			if err := writeU32(f, index); err != nil {
				return fmt.Errorf("failed to variable %d of %s to %s: %s", i, name, path, err)
			}
		}
	}

	return nil
}

// Find all the things in s which are not in template
func (s *Store) missingIds(template *Store) *parse.MessageFile {
	messages := []parse.Message{}
	types := []parse.Type{}
	ids := s.MessageIDs()
	sort.Strings(ids)
	for _, id := range ids {
		if template == nil || !template.HasMessage(id) {
			messages = append(messages, parse.Message{id, s.Message(id)})
		}
		if template == nil || len(s.MessageVarTypes(id)) != 0 && len(template.MessageVarTypes(id)) == 0 {
			vars := []parse.Var{}
			for name, ty := range s.MessageVarTypes(id) {
				vars = append(vars, parse.Var{name, ty})
			}
			types = append(types, parse.Type{id, vars})
		}
	}
	return parse.NewFromData("// Generated by ouro-tools", messages, types)
}

func (s *Store) WriteText(path string, template *Store) error {
	missing := s.missingIds(template)

	if template == nil {
		return s.writeTextTo(path, missing)
	} else {
		basedir := filepath.Dir(path)

		// If the target is an existing directory, just write the files into that
		info, err := os.Stat(path)
		if err == nil && info.IsDir() {
			basedir = path
		}

		for relname, file := range template.inputFiles {
			name := filepath.Join(basedir, relname)

			if err := s.writeTextTo(name, file); err != nil {
				return err
			}
		}

		// Always one comment at the start, skip the file if that's all there is
		if len(missing.Lines) > 1 {
			name := filepath.Join(basedir, "missing-data.txt")
			if err := s.writeTextTo(name, missing); err != nil {
				return err
			}
		}
	}
	return nil
}

func (s *Store) writeTextTo(path string, file *parse.MessageFile) error {
	if err := os.MkdirAll(filepath.Dir(path), os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directory %s: %s", filepath.Dir(path), err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create %s: %s", path, err)
	}
	defer f.Close()

	if !file.TypeFile {
		// For no apparent reason, messages files have a BOM and type files do not
		f.WriteString("\uFEFF")
	}

	if s.Verbose {
		fmt.Printf("writing %s\n", path)
	}

	for _, line := range file.Lines {
		f.WriteString(line.FormatWith(s))
	}

	return nil
}
